<p>In some programming languages, <b><code>eval</code></b> , short for the English evaluate, is a function which evaluates a string as though it were an expression in the language, and returns a result; in others, it executes multiple lines of code as though they had been included instead of the line including the <code>eval</code>. The input to <code>eval</code> is not necessarily a string; it may be structured representation of code, such as an abstract syntax tree (like Lisp forms), or of special type such as <code>code</code> (as in Python). The analog for a statement is exec, which executes a string (or code in other format) as if it were a statement; in some languages, such as Python, both are present, while in other languages only one of either <code>eval</code> or <code>exec</code> is.
</p><p>Eval and apply are instances of meta-circular evaluators, interpreters of a language that can be invoked within the language itself.</p>

<h2>Security risks</h2>
<p>Using <code>eval</code> with data from an untrusted source may introduce security vulnerabilities. For instance, assuming that the <code>get_data()</code> function gets data from the Internet, this Python code is insecure:
</p>

<p>An attacker could supply the program with the string <code>"session.update(authenticated=True)"</code> as data, which would update the <code>session</code> dictionary to set an authenticated key to be True. To remedy this, all data which will be used with <code>eval</code> must be escaped, or it must be run without access to potentially harmful functions.
</p>

<h2>Implementation</h2>
<p>In interpreted languages, <code>eval</code> is almost always implemented with the same interpreter as normal code. In compiled languages, the same compiler used to compile programs may be embedded in programs using the <code>eval</code> function; separate interpreters are sometimes used, though this results in code duplication.
</p>

<h2>Programming languages</h2>
<h3>ECMAScript</h3>
<h4>JavaScript</h4>
<p>In JavaScript, <code>eval</code> is something of a hybrid between an expression evaluator and a statement executor. It returns the result of the last expression evaluated.
</p><p>Example as an expression evaluator:
</p>

<p>Example as a statement executor:
</p>

<p>One use of JavaScript's <code>eval</code> is to parse JSON text, perhaps as part of an Ajax framework.  However, modern browsers provide <code>JSON.parse</code> as a more secure alternative for this task.
</p>

<h4>ActionScript</h4>
<p>In ActionScript (Flash's programming language), <code>eval</code> cannot be used to evaluate arbitrary expressions. According to the Flash 8 documentation, its usage is limited to expressions which represent "the name of a variable, property, object, or movie clip to retrieve. This parameter can be either a String or a direct reference to the object instance."</p><p>ActionScript 3 does not support eval.
</p><p>The ActionScript 3 Eval Library and the D.eval API are ongoing development projects to create equivalents to <code>eval</code> in ActionScript 3.
</p>

<h3>Lisp</h3>
<p>Lisp was the original language to make use of an <code>eval</code> function in 1958.  In fact, definition of the <code>eval</code> function led to the first implementation of the language interpreter.
Before the <code>eval</code> function was defined, Lisp functions were manually compiled to assembly language statements. However, once the <code>eval</code> function had been manually compiled it was then used as part of a simple read-eval-print loop which formed the basis of the first Lisp interpreter.
</p><p>Later versions of the Lisp <code>eval</code> function have also been implemented as compilers.
</p><p>The <code>eval</code> function in Lisp expects a form to be evaluated and executed as argument. The return value of the given form will be the return value of the call to <code>eval</code>.
</p><p>This is an example Lisp code:
</p>

<p>Lisp is well known to be very flexible and so is the <code>eval</code> function. For example, to evaluate the content of a string, the string would first have to be converted into a Lisp form using the <code>read-from-string</code> function and then the resulting form would have to be passed to <code>eval</code>:
</p>

<p>One major point of confusion is the question, in which context the symbols in the form will be evaluated. In the above example, <code>form1</code> contains the symbol <code>+</code>. Evaluation of this symbol must yield the function for addition to make the example work as intended. Thus some dialects of lisp allow an additional parameter for <code>eval</code> to specify the context of evaluation (similar to the optional arguments to Python's <code>eval</code> function - see below). An example in the Scheme dialect of Lisp (R<sup>5</sup>RS and later):
</p>

<h3>Perl</h3>
<p>In Perl, the <code>eval</code> function is something of a hybrid between an expression evaluator and a statement executor. It returns the result of the last expression evaluated (all statements are expressions in Perl programming), and allows the final semicolon to be left off.
</p><p>Example as an expression evaluator:
</p>

<p>Example as a statement executor:
</p>

<p>Perl also has <code>eval</code> <i>blocks</i>, which serves as its exception handling mechanism (see Exception handling syntax#Perl). This differs from the above use of <code>eval</code> with strings in that code inside <code>eval</code> blocks is interpreted at compile-time instead of run-time, so it is not the meaning of <code>eval</code> used in this article.
</p>

<h3>PHP</h3>
<p>In PHP, <code>eval</code> executes code in a string almost exactly as if it had been put in the file instead of the call to <code>eval()</code>. The only exception is that errors are reported as coming from a call to <code>eval()</code>, and return statements become the result of the function.
</p><p>Unlike some languages, the argument to <code>eval</code> must be a string of one or more complete statements, not just expressions; however, one can get the "expression" form of <code>eval</code> by putting the expression in a return statement, which causes <code>eval</code> to return the result of that expression.
</p><p>Unlike some languages, PHP's <code>eval</code> is a "language construct" rather than a function, and so cannot be used in some contexts where functions can be, like higher-order functions.
</p><p>Example using echo:
</p>

<p>Example returning a value:
</p>

<h3>Lua</h3>
<p>In Lua 5.1, <code>loadstring</code> compiles Lua code into an anonymous function.
</p><p>Example as an expression evaluator:
</p>

<p>Example to do the evaluation in two steps:
</p>

<p>Lua 5.2 deprecates <code>loadstring</code> in favor of the existing <code>load</code> function, which has been augmented to accept strings. In addition, it allows providing the function's environment directly, as environments are now upvalues.
</p>

<h3>PostScript</h3>
<p>PostScript's <code>exec</code> operator takes an operand — if it is a simple literal it pushes it back on the stack. If one takes a string containing a PostScript expression however, one can convert the string to an executable which then can be executed by the interpreter, for example:
</p>

<p>converts the PostScript expression
</p>

<p>which pops the string "Hello World" off the stack and displays it on the screen, to have an executable type, then is executed.
</p><p>PostScript's <code>run</code> operator is similar in functionality but instead the interpreter interprets PostScript expressions in a file, itself.
</p>

<h3>Python</h3>
<p>In Python, the <code>eval</code> function in its simplest form evaluates a single expression.
</p><p><code>eval</code> example (interactive shell):
</p>

<p>The <code>eval</code> function takes two optional arguments, <code>global</code> and <code>locals</code>, which allow the programmer to set up a restricted environment for the evaluation of the expression.
</p><p>The <code>exec</code> statement (or the <code>exec</code> function in Python 3.x) executes statements:
</p><p><code>exec</code> example (interactive shell):
</p>

<p>The most general form for evaluating statements/expressions is using code objects. Those can be created by invoking the <code>compile()</code> function and by telling it what kind of input it has to compile: an "<code>exec</code>" statement, an "<code>eval</code>" statement or a "<code>single</code>" statement:
</p><p><code>compile</code> example (interactive shell):
</p>

<h3>D</h3>
<p>D is a statically compiled language and therefore does not include an "<code>eval</code>" statement in the traditional sense, but does include the related "<code>mixin</code>" statement.  The difference is that, where "<code>eval</code>" interprets a string as code at runtime, with a "<code>mixin</code>" the string is statically compiled like ordinary code and must be known at compile time.  For example:
</p>

<p>The above example will compile to exactly the same assembly language instructions as if "<code>num++;</code>" had been written directly instead of mixed in. The argument to mixin doesn't need to be a string literal, but arbitrary expressions resulting in a string value, including function calls, that can be evaluated at compile time.
</p>

<h3>ColdFusion</h3>
<p>ColdFusion's <code>evaluate</code> function lets you evaluate a string expression at runtime.
</p>

<p>It is particularly useful when you need to programatically choose the variable you want to read from.
</p>

<h3>Ruby</h3>
<p>The Ruby programming language interpreter offers an <code>eval</code> function similar to Python or Perl, and also allows a scope, or binding, to be specified.
</p><p>Aside from specifying a function's binding, <code>eval</code> may also be used to evaluate an expression within a specific class definition binding or object instance binding, allowing classes to be extended with new methods specified in strings.
</p>

<h3>Forth</h3>
<p>Most standard implementations of Forth have two variants of <code>eval</code>: <code>EVALUATE</code> and <code>INTERPRET</code>.
</p><p>Win32FORTH code example:
</p>

<h3>BASIC</h3>
<h4>REALbasic</h4>
<p>In REALbasic, there is a class called RBScript which can execute REALbasic code at runtime. RBScript is very sandboxed—only the most core language features are there, and you have to allow it access to things you want it to have. You can optionally assign an object to the context property. This allows for the code in RBScript to call functions and use properties of the context object. However, it is still limited to only understanding the most basic types, so if you have a function that returns a Dictionary or MySpiffyObject, RBScript will be unable to use it. You can also communicate with your RBScript through the Print and Input events.
</p>

<h4>VBScript</h4>
<p>Microsoft's VBScript, which is an interpreted language, has two constructs. <code>Eval</code> is a function evaluator that can include calls to user-defined functions. (These functions may have side-effects such as changing the values of global variables.) <code>Execute</code> executes one or more colon-separated statements, which can change global state.
</p><p>Both VBScript and JScript <code>eval</code> are available to developers of compiled Windows applications (written in languages which do not support Eval) through an ActiveX control called the Microsoft Script Control, whose Eval method can be called by application code. To support calling of user-defined functions, one must first initialize the control with the AddCode method, which loads a string (or a string resource) containing a library of user-defined functions defined in the language of one's choice, prior to calling Eval.
</p>

<h4>Visual Basic for Applications</h4>
<p>Visual Basic for Applications (VBA), the programming language of Microsoft Office, is a virtual machine language where the runtime environment compiles and runs p-code. Its flavor of Eval supports only expression evaluation, where the expression may include user-defined functions and objects (but not user-defined variable names). Of note, the evaluator is different from VBS, and invocation of certain user-defined functions may work differently in VBA than the identical code in VBScript.
</p>

<h3>Smalltalk</h3>
<p>As Smalltalk's compiler classes are part of the standard class library and usually present at run time, these can be used to evaluate a code string.
</p>

<p>Because class and method definitions are also implemented by message-sends (to class objects), even code changes are possible:
</p>

<h3>Tcl</h3>
<p>The Tcl programming language has a command called <code>eval</code>, which executes the source code provided as an argument.  Tcl represents all source code as strings, with curly braces acting as quotation marks, so that the argument to <code>eval</code> can have the same formatting as any other source code.
</p>

<h3>bs</h3>
<p>bs has an <code>eval</code> function that takes one string argument. The function is both an expression evaluator and a statement executor. In the latter role, it can also be used for error handling. The following examples and text are from the <code>bs</code> man page as appears in the UNIX System V Release 3.2 Programmer's Manual.</p>
<blockquote class="templatequote"><p>The string argument is evaluated as a <code>bs</code> expression. The function is handy for converting numeric strings to numeric internal form. The <code>eval</code> can also be used as a crude form of indirection, as in the following (Note that, in <code>bs</code>, <code>_</code> (underscore) is the concatenation operator.):
</p>
<p>which increments the variable <code>xyz</code>.
</p><p>In addition, <code>eval</code> preceded by the interrogation operator, <code>?</code>, permits the user to control <code>bs</code> error conditions. For example:
</p>

<p>returns the value zero if there is no file named "XXX" (instead
of halting the user's program). 
</p><p>The following executes a <code>goto</code> to the label <code>L</code> (if it exists):
</p>
</blockquote>

<h2>Command-line interpreters</h2>
<h3>Unix shells</h3>
<p>The <i>eval</i> command is present in all Unix shells, including the original "sh" (Bourne shell). It concatenates all the arguments with spaces, then re-parses and executes the result as a command. <span><code>sh(1)</code></span> – FreeBSD General Commands Manual
</p>

<h3>Windows PowerShell</h3>
<p>In Windows PowerShell, the <code>Invoke-Expression</code> Cmdlet serves the same purpose as the eval function in programming languages like JavaScript, PHP and Python.
The Cmdlet runs any Windows PowerShell expression that is provided as a command parameter in the form of a string and outputs the result of the specified expression.
Usually, the output of the Cmdlet is of the same type as the result of executing the expression. However, if the result is an empty array, it outputs <code>$null</code>. In case the result is a single-element array, it outputs that single element. Similar to JavaScript, Windows PowerShell allows the final semicolon to be left off.
</p><p>Example as an expression evaluator:
</p>

<p>Example as a statement executor:
</p>

<h2>Microcode</h2>
<p>In 1966 IBM Conversational Programming System (CPS) introduced a microprogrammed function <code>EVAL</code> to perform "interpretive evaluation of expressions which are written in a modified Polish-string notation" on an IBM System/360 Model 50. Microcoding this function was "substantially more" than five times faster compared to a program that interpreted an assignment statement.</p>

<h2>Theory</h2>
<p>In theoretical computer science, a careful distinction is commonly made between eval and apply. <i>Eval</i> is understood to be the step of converting a quoted string into a callable function and its arguments, whereas <i>apply</i> is the actual call of the function with a given set of arguments. The distinction is particularly noticeable in functional languages, and languages based on lambda calculus, such as LISP and Scheme.  Thus, for example, in Scheme, the distinction is between
</p>
 
<p>where the form (f x) is to be evaluated, and
</p>
 
<p>where the function <i>f</i> is to be called with argument <i>x</i>.
</p><p><i>Eval</i> and <i>apply</i> are the two interdependent components of the <i>eval-apply cycle</i>, which is the essence of evaluating Lisp, described in SICP.</p><p>In category theory, the <i>eval</i> morphism is used to define the closed monoidal category.  Thus, for example, the category of sets, with functions taken as morphisms, and the cartesian product taken as the product, forms a Cartesian closed category.  Here, <i>eval</i> (or, properly speaking, <i>apply</i>) together with its right adjoint, currying, form the  simply typed lambda calculus, which can be interpreted to be the morphisms of Cartesian closed categories.
</p>

<h2>References</h2>
<h2>External links</h2>
<ul><li>ANSI and GNU Common Lisp Document: eval function</li>
<li>Python Library Reference: eval built-in function</li>
<li>Jonathan Johnson on exposing classes to RBScript</li>
<li>Examples of runtime evaluation in several languages on Rosetta Code</li></ul>